<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Karla:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>ECE 3400 Spring 2021 Wiki by kr397</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>ECE 3400 Wiki</h1>
        <h2>Spring 2021</h2>
        <h2><b>Krithik Ranjan</b> kr397</h2>
        <!--
        <a href="https://github.coecis.cornell.edu/kr397/ece3400-sp2021" class="button"><small>View project on</small> GitHub</a>
        -->
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h1>
<a id="lab-1-light-following-robot-part-1" class="anchor" href="#lab-1-light-following-robot-part-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>Lab 1</strong> Light Following Robot Part 1</h1>
<h2>
<a id="objective" class="anchor" href="#objective" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Objective</h2>
<p>The goal of this lab was to familiarize ourselves with Arduino and some basic electrical components that we will be using to create a light following robot over the next few labs. In this course, we are using the Arduino Nano Every microcontroller board, which, in this lab, we connected to a dual photoresistor circuit set up on a breadboard. We tested the circuit by programming the Arduino and observing its print output through the serial terminal. The steps of this lab involved setting up the Arduino software environment on our local computer, testing some basic code, setting up the circuit, writing more complicated code that interfaces with the sensors and will be used to control the robot in future labs.</p>
<h2>
  <a a="materials-used" class="anchor" href="#materials-used" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Materials Used
</h2>
<ul>
  <li>Arduino Nano Every</li>
  <li>Photoresistors</li>
  <li>Resistors</li>
  <li>Jumpers</li>
  <li>Breadboard</li>
</ul> 

<h2>
<a id="installing-the-arduino-ide" class="anchor" href="#installing-the-arduino-ide" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Installing the Arduino IDE</h2>
<p>As described in the lab handout, I installed and set up the latest version of the Arduino IDE to be compatible with our Arduino Nano Every board. I also opened a few built-in examples to try out on the Arduino (that could work without any additional hardware).</p>
<figure>
  <img src="images/image5.png">
  <figcaption><center><i>Figure: Arduino IDE</i></center></figcaption>
</figure>
<p>Having worked with the Arduino before and being familiar with the IDE, I ventured out to learn some advanced methods of using the Arduino. The Arduino organization has recently launched a command line tool called <code>arduino-cli</code> that can be used to perform all the functions of the IDE, straight from the terminal. This was an exciting, new application that can make it faster and easier (in some cases) to work with the Arduino. A detailed introduction to this can be found at Arduino’s blog <a href="https://blog.arduino.cc/2020/03/13/arduino-cli-an-introduction/">here</a>.</p>
<p>Using the CLI involves a simple download from their website and adding it to the user’s path, after which, it can be directly used on the terminal with <code>arduino-cli</code> (shown on Windows Terminal - Powershell). The tool can then be set up and used with the Arduino Nano Every as described in the following steps.</p>
<figure>
  <img src="images/image11.png">
  <figcaption><i><center>Figure: Output of the <code>arduino-cli</code> showing all its commands</center></i></figcaption>
</figure>
<ol>
<li>First, to install the board onto the system, connect it to the computer and run the following commands.</li>
</ol>
<pre><code>&gt; arduino-cli board list
</code></pre>
<p>will show the connected boards with details about their ports and cores.</p>
<pre><code>&gt; arduino-cli core list 
</code></pre>
<p>will show all of the cores (boards) that have been installed.</p>
<pre><code>&gt; arduino-cli core install arduino:megaavr
</code></pre>
<p>will install the core (as shown in the <code>board list</code> command).</p>
<figure>
  <img src="images/image12.png">
  <figcaption><i><center>Figure: Install a board</center></i></figcaption>
</figure>
<ol start="2">
<li>Once the board has been installed, a new sketch can be created as follows. This creates the <code>blink.ino</code> file in the folder <code>blink</code> as per Arduino’s convention.</li>
</ol>
<pre><code>&gt; arduino-cli sketch new blink
</code></pre>
<ol start="3">
<li>The sketch can be compiled with the following command with a <code>-b</code> flag to specify the board that it needs to be compiled for, using the FQBN displayed in the <code>board list</code> command. The verbose <code>-v</code> flag can be used for a detailed output.</li>
</ol>
<pre><code>&gt; arduino-cli compile -b arduino:megaavr:nona4809
</code></pre>
<figure>
  <img src="images/image7.png">
  <figcaption><i><center>Figure: Compile a sketch</center></i></figcaption>
</figure>
<ol start="4">
<li>This compiled sketch can then be uploaded to the board by specifying the FQBN and the port as shown. The <code>-v</code> flag will give the complete output.</li>
</ol>
<pre><code>&gt; arduino-cli upload -b arduino:megaavr:nona4809 -p COM5
</code></pre>
<figure>
  <img src="images/image9.png">
  <figcaption><i><center>Figure: Upload a sketch</center></i></figcaption>
</figure>
<ol start="5">
<li>To prevent having to type things like the FQBN and serial port every time we compile and upload a sketch, we can attach a board to the particular sketch (like it is done in the IDE). This can be done by passing in the serial port.</li>
</ol>
<pre><code>&gt; arduino-cli board attach COM5
</code></pre>
<figure>
  <img src="images/image3.png">
  <figcaption><i><center>Figure: Attach a board and then compile, upload</center></i></figcaption>
</figure>
<ol start="6">
<li>For further increase in efficiency, once a board is attached, we can compile and upload a sketch in a single command as well.</li>
</ol>
<pre><code>&gt; arduino-cli compile --upload
</code></pre>
<figure>
  <img src="images/image10.png">
  <figcaption><i><center>Figure: Compile and upload at once</center></i></figcaption>
</figure>
<p>This is a brief crash course for the Arduino CLI tool compiled with the help of their existing tutorials and blog posts, which I have included here for future reference in the labs.</p>
<h2>
<a id="controlling-the-on-board-led" class="anchor" href="#controlling-the-on-board-led" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Controlling the on-board LED</h2>
<p>Once the environment was set up, we had to try out a basic program on the Arduino. This was inspired by the <code>blink.c</code> example in the Arduino tutorials which simply made the LED on-board the Arduino Nano Every glow every 1 second (1000ms off, 1000ms on). The on-board LED on the Nano Every is connected to the digital pin <code>D13</code>, which can be accessed by the <code>LED_BUILTIN</code> constant. For this section, I followed the steps given in the lab handout to understand the given code, find the <code>LED_BUILTIN</code> constant in <code>pins_arduino.h</code> file, compile, debug and upload the code to the board. I also varied the time durations between the LED toggles to observe different blink patterns, one of which has been shown in the GIF below (2000ms on, 500ms off).</p>
<figure>
  <img src="images/blink.gif">
  <figcaption><i><center>Video: Modified blink sketch with the built-in LED</center></i></figcaption>
</figure>
<h2>
<a id="cds-photoresistors" class="anchor" href="#cds-photoresistors" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>CdS Photoresistors</h2>
<p>The main sensor that we use in this lab to create the light-following robot is the CdS photoresistor. This is a passive component that changes its resistance based on the amount of light it is exposed to (illuminance). Through referring the datasheet of this resistor, I found that its resistance decreases with increase in illumination, with up to 0.5 MOhm resistance in dark and minimum of 16-33 KOhm when its illuminated. The robot we will create in the labs will have two such sensors acting as the "eyes" for the machine. Since the sensor is just a passive resistor, we create a simple circuit to "transduce a change of incident light onto the photoresistor into a measurable change of Voltage" (Lab handout). This circuit was provided in the handout, and has been shown below. </p>
<figure>
  <center>
  <img src="images/circuit.png" width=40%>
  <figcaption><i>Figure: Given circuit diagram with the photoresistor</i></figcaption>
</center>
</figure>
<p>We can see that this is a voltage divider circuit, where the voltage at <code>Vout</code> is proportional to either of the resistances. This relationship can be derived as <code>Vout = Vin * ( R1 / (R1 + Rp) )</code> where <code>Rp</code> is the photoresistor and <code>R1</code> is the resistor in series with it. For this lab, we chose <code>R1 = 10 KOhm</code>. Since we know that the resistance reduces as the illumination around the sensor increases, we find that the value of <code>Vout</code> increases with illumination. </p>
<p>
  In order to use this sensor to determine the illumination in the surroundings, we use the on-chip Analog-to-Digital Converter (ADC) on the ATMega4809 processor. The ADC measures any voltage in operating voltage range and outputs a numerical value. In case of the Nano Every, the ADC is 10-bit, and for each measurement, returns a value between 0-1023. To obtain this reading, we use the <code>analogRead()</code> function on the Arduino and connect the <code>Vout</code> to one of the analog pins (<code>A0</code> in this lab). This ADC result (between 0-1023) can be used to determine the measured voltage <code>V</code> through the relationship <code>Result = ( 1023 * V ) / Vref</code>. 
</p>
<p>
  We need to determine the exact value of <code>Vref</code> to be able to accurately compute <code>V</code>. I first did that with the given Arduino sketch <code>readADC_CTRLCbit.ino</code> which simply prints out the bits 4 and 5 of the <code>ADC0.CTRLC</code> register which corresponds to <code>REFSEL</code>. We find that these bits are <code>01</code>, meaning that <code>Vref = Vdd = 5V</code> when the Arduino is powered by USB. In order to ensure that this voltage is 5V, we can wire a circuit to keep 3.3V pin as the <code>Vin</code> for the ADC(<code>A0</code>), and then work back to calculate <code>Vref</code>. Running the <code>CdS_ReadA0.ino</code> sketch gives <code>result = 675</code> and therefore <code>Vref = 5V</code>.
</p>
<figure>
  <center>
  <img src="images/image8.png">
  <figcaption><i>Figure: Bits of ADC.CTRLC register</i></figcaption>
</center>
</figure>
<p>
  While using the on-board ADC to measure voltages, we need <code>Vin &lt;= Vref</code> for safety of the circuit. From the datasheet of ATMega4809, we see that none of the pins of the microcontroller can be at maximum voltage <code>&gt; Vdd + 0.5V</code> with respect to ground. Any greater than this would result in inward flow of current into the board, potentially leading to short and damage to the board. 
</p>
<p>
  From the assumptions of the resistance based on the information on the CdS datasheet, we can calculate the minimum and maximum <code>result</code> that we may obtain with the given circuit. 
  <pre><code>When dark, Rp = 0.5 MOhm = 5 x 10^5 Ohm
Using R1 = 10 KOhm = 10^4 Ohm
From a voltage divider expression,
V = ( R1 / ( R1 + Rp ) ) x Vref, where Vref = 5V
V = ( 10^4 / ( 10^4 + 5 x 10^5 ) ) x 5
Therefore, V = 0.98V
Now, result = ( 1023 x V ) / Vref
result = 200</code></pre>  
  <pre><code>Similarly when illuminated , Rp = 16 KOhm = 16 x 10^3 Ohm
Using R1 = 10 KOhm = 10^4 Ohm
From a voltage divider expression,
V = ( R1 / ( R1 + Rp ) ) x Vref, where Vref = 5V
V = ( 10^4 / ( 10^4 + 16 x 10^3 ) ) x 5
Therefore, V = 1.92V
Now, result = ( 1023 x V ) / Vref
result = 393</code></pre>
</p>
<p>
  After understanding the background knowledge of the circuit, we had build the circuit of the robot with the photoresistors. I first set up one side of the sensor circuit based on the given diagram, and tested it with the <code>CdS_ReadA0.ino</code> file. This circuit has been shown below. The serial monitor printed varying values (0-1023) of light levels near the sensor as I changed the lighting in my room. For three different types of light conditions, I observed the following:
  <ul>
    <li><b>Very bright conditions: </b><code>result = 850</code></li>
    <li><b>Moderately bright conditions: </b><code>result = 720</code></li>
    <li><b>Low bright conditions: </b><code>result = 320</code></li>
  </ul>
  <figure>
    <center>
      <img src="images/image4.jpg">
      <figcaption><i>Figure: Single sensor circuit</i></figcaption>
  </center>
  </figure>
  We observe that the output values are much higher than those calculated above. This implies that the resistor is capable of much smaller resistances than the ones certified in the datasheet. Based on this single sensor circuit, I then built the complete circuit with two photoresistors on different sides, serving as the "eyes" for the robot.
  <figure>
    <center>
      <img src="images/image2.jpg">
      <figcaption><i>Figure: Complete robot circuit with two photoresistors</i></figcaption>
    </center>
  </figure>
</p>
<h2>
<a id="coding-the-robot" class="anchor" href="#coding-the-robot" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Coding the Robot</h2>
<p>
  Once the circuit of the robot was ready, we needed to write the Arduino sketch to be able to control it. This was based on the given <code>CdS_ReadA0.ino</code> code where instead of one analog input at <code>A0</code>, I used two inputs at <code>A0</code>, <code>A1</code> to obtain a reading from both sensors. The set up of both pins was similar and the obtained values were stored in <code>sensorLeft</code> and <code>sensorRight</code> variables. For this lab, these values were simply printed on the serial monitor as shown below, but they will be used to actually determine the direction of the robot and make it follow light. A pre-step for that is normalization of the measurements. This simply calculates the output of each sensor, relative to the total sensor output, which makes it possible to simply determine the brighter side without worrying about a threshold which might need to be adjusted in different lighting conditions. The normalization measurements are calculated as follows:
  <pre><code>NMleft = sensorLeft / ( sensorLeft + sensorRight )
NMright = sensorRight / (sensorRight + sensorLeft ) = 1 - NMleft</code></pre>
  After observing the values of <code>NMleft</code> and <code>NMright</code> in a range of different lighting conditions and desired behaviors, we can find the appropriate threshold which will be used to determine the direction of the robot.
  <figure>
    <center>
      <img src="images/image1.png">
      <figcaption><i>Figure: Serial monitor output for the final code</i></figcaption>
    </center>
  </figure>
</p>
        </section>

        <aside id="sidebar">
          <h3>Back to <a href="index.html">Home</a></h3>
          <h2><a href="#objective">Objective</a></h2>
          <h2><a href="#materials-used">Materials Used</a></h2>
          <h2><a href="#installing-the-arduino-ide">Installing the Arduino IDE</a></h2>
          <h2><a href="#controlling-the-on-board-led">Controlling the on-board LED</a></h2>
          <h2><a href="#cds-photoresistors">CdS Photoresistors</a></h2>
          <h2><a href="#coding-the-robot">Coding the Robot</a></h2>

          <br>
          <p class="repo-owner"><a href="https://github.coecis.cornell.edu/kr397/ece3400-sp2021"></a>Maintained by <a href="https://github.coecis.cornell.edu/kr397">kr397</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>
