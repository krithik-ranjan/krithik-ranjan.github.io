<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Karla:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>ECE 3400 Spring 2021 Wiki by kr397</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>ECE 3400 Wiki</h1>
        <h2>Spring 2021</h2>
        <h2><b>Krithik Ranjan</b> kr397</h2>
        <!--
        <a href="https://github.coecis.cornell.edu/kr397/ece3400-sp2021" class="button"><small>View project on</small> GitHub</a>
        -->
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h1>
<a id="lab-3-filtering-and-fft" class="anchor" href="#lab-3-filtering-and-fft" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><strong>Lab 3</strong> Filtering and FFT</h1>

<h2>
<a id="objective" class="anchor" href="#objective" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Objective</h2>
<p>The goal of this lab was to develop and understand active and passive filters on an amplified microphone circuit. These were first implemented both as simulations on LTSpice, and then we created physical circuits with a microphone and amplifier connected to the Arduino Nano Every. Over successive parts of the lab, we built circuits for lowpass, highpass, and bandpass filters, who’s output was converted to a frequency spectrum using a Fast-Fourier Transform (FFT). The FFT was first performed on MATLAB, and then on the Arduino itself and visualized using Bode and stem plots to ensure that the frequencies are perceived correctly.</p>
<p>This lab was distinct from the work done in previous labs, in that we did not use any part of the robot or light sensors, but solely implemented and tested the audio input. In the next lab, this tested microphone system will be integrated with the overall robot to perform tasks based on frequencies of audio perceived.</p>

<h2>
    <a id="materials-used" class="anchor" href="#materials-used" aria-hidden="true">
        <span aria-hidden="true" class="octicon octicon-link">
        </span>
    </a>
    Materials Used
</h2>
<ul>
    <li>Arduino Nano Every</li>
    <li>Electret microphone</li>
    <li>LM358P Operational Amplifier</li>
    <li>Resistors: </li>
    <li>Capacitors: </li>
    <li>Jumpers</li>
    <li>Breadboard</li>
</ul>    

<h2>
<a id="getting-familiar-with-ltspice" class="anchor" href="#getting-familiar-with-ltspice" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Getting Familiar with LTSpice</h2>
<p>In the first part of this lab, we experimented with the popular electrical simulation tool LTSpice to simulate the behavior of the three filters. This is an open-source software, which we just downloaded and installed from the Analog Devices website. LTSpice offers an interface where we can easily create schematics with a range of components, and simultaneously plot the behavior of any point in the circuit. Following the steps described in the lab handout, I first built and simulated some example filter circuits and then the ones that we will be using in next parts of the labs.</p>
<p>The lowpass and highpass filters were built with R = 1.2 KOhm and C = 0.1 uF, the schematics of which have been shown below. On LTSpice, these performed as expected when we observed the simulations, giving the cut-off frequency of 1326 Hz that had an amplitude of -3 dB. This meant that the low pass attenuates sound waves of greater frequency than this, and the high pass filter attenuates sound waves of lower frequencies.</p>
<pre><code>cut-off freq = 1 / ( R * C ) = 1 / ( 1.2K * 0.1u ) = 1326 Hz
</code></pre>
<figure>
    <center><i>
        <img src="images/lab3/lowpass_circuit.png">
        <figcaption>Figure: Low pass filter circuit on LTSpice</figcaption>
    </i></center>
</figure>
<figure>
    <center><i>
        <img src="images/lab3/lowpass_response.png">
        <img src="images/lab3/lowpass_cutoff.png">
        <figcaption>Figure: Simulated low pass filter response with cut-off frequency</figcaption>
    </i></center>
</figure>
<figure>
    <center><i>
        <img src="images/lab3/highpass_circuit.png">
        <figcaption>Figure: High pass filter circuit on LTSpice</figcaption>
    </i></center>
</figure>
<figure>
    <center><i>
        <img src="images/lab3/highpass_response.png">
        <img src="images/lab3/highpass_cutoff.png">
        <figcaption>Figure: Simulated high pass filter response with cut-off frequency</figcaption>
    </i></center>
</figure>

<p>The third filter we experimented with was the bandpass filter, which attenuates all sound waves with frequencies outside a desired range (500 Hz to 900 Hz in our case). For this, we implemented an active filter circuit based on the Butterworth 4-pole bandpass filter that was discussed in class. Among other circuits for bandpass filters, the Butterworth has no ripples in the pass band, and has an acceptable transition from pass band to stop band.</p>
<figure>
    <center><i>
        <img src="images/lab3/filters.png">
        <figcaption>Figure: Types of Bandpass filters and their responses (from lecture notes)</figcaption>
    </i></center>
</figure>
<p>Since this was an active filter, building it also required an op-amp component. This was the LM358P, for which we retrieved an LTSpice schematic component from the website of the manufacturer, Texas Instruments. The 4-pole Butterworth circuit using two of these op-amps has been shown below. This also received an expected response in the simulation, with a flat pass band in the desired range, and attenuated frequencies outside it.</p>
<figure>
    <center><i>
        <img src="images/lab3/bandpass_circuit.png">
        <figcaption>Figure: Circuit of 4-pole Butterworth bandpass (from handout)</figcaption>
    </i></center>
</figure>
<figure>
    <center><i>
        <img src="images/lab3/bandpass_schematic.png">
        <figcaption>Figure: LTSpice schematic of 4-pole Butterworth bandpass circuit</figcaption>
    </i></center>
</figure>
<figure>
    <center><i>
        <img src="images/lab3/bandpass_response.png">
        <figcaption>Figure: Simulated bandpass frequency response</figcaption>
    </i></center>
</figure>

<h2>
<a id="building-and-testing-microphone" class="anchor" href="#building-and-testing-microphone" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Building and Testing the Microphone Circuit</h2>
<p>After having simulated the different filters in LTSpice, we moved to actually building the system, starting with the basic microphone. This was an electret microphone, which was set up with a resistor of R = 3.3 KOhm and C = 10 uF, and the output was wired directly to an analog pin on the Arduino. I carefully created this circuit with reference to the lab handout, ensuring that the polarity of both the microphone and the capacitor is considered.</p>
<figure>
    <center><i>
        <img src="images/lab3/mic_schematic.png">
        <img src="images/lab3/mic_circuit.jpg">
        <figcaption>Figure: Schematic of microphone connection (from handout) and its circuit</figcaption>
    </i></center>
</figure>
<p>The output from this microphone circuit went directly to the Arduino, where the voltage level was measured on an analog pin through the ADC.These values were modified by the Arduino into signed values of a sound wave, and then sent to the computer through the serial port (USB). These were then read by a MATLAB script that calculated the FFT of the collected samples and displayed the frequency spectrum as a stem plot to show the most prominent frequency peak.</p>
<p>The range of frequencies identified by FFT is determined by the sampling frequency of the system, i.e. the rate at which the device reads discrete sound wave values (<code>0 to Fs / 2</code>). In order to keep this rate as high as possible on the Arduino, we needed to increase the speed of the ADC reading the output of the microphone. With the normal method of using <code>analogRead()</code>, the Arduino calls a function every time, which goes through a series of steps to read a value from the analog pin, which can be a very slow process. Therefore, in this lab, we configured the ADC to use a ‘Free-running’ mode, which meant that the ADC was fixed on a single analog pin, from which it read and output values continuously, as fast as possible. In order to code this into the Arduino sketch, I referred to the <i>Getting Started with the ADC</i> document. The sample code was modified to make the ADC prescaler at 16, and fixing for the appropriate analog pin. Whenever a value was ready to be read, the Arduino shifted and scaled the values to a signed 16-bit integer (from the 10-bit unsigned ADC output) to better represent a sound wave for the FFT computation. These values were successively printed to the serial, which was set at a baud rate of 115200 to keep up with the sampling frequency.</p>
<pre><code>10-bit ADC value converted to int16_t as follows:
Original reading: 0 - 1023 --> Offset = 512
ADC0_val - 512: -512 - 511 --> Range size = 1024
int16_t: -32768 - 32767    --> Range size = 65536
.: ADC0_conv_val = Shifted ADC0_val * (65536 / 1024) --> 2^6 scaling
==> ADC0_conv_val = ( ADC0_val - 512 ) * 64;
</code></pre>
<p>Once the Arduino was programmed to read and output the microphone data as fast as possible, we moved to the MATLAB code to obtain the data from the serial port and compute its FFT. The overall sketch of the MATLAB script was given to us that essentially performed the following steps:</p>
<p>
<ol>
    <li>Play a sound of a preset frequency for a duration of time</li>
    <li>Read a set of values from the serial port and convert them to usable data</li>
    <li>Compute the FFT of the sound data</li> 
    <li>Display the sound wave and the FFT spectrum in plots</li> 
</ol>
</p>
<p>We were tasked with implementing the latter half of the script, while modifying the existing code as necessary. In order to compute the FFT of the data gathered, we had to determine the sampling frequency. Since the values are now being read on the computer with MATLAB, the rate at which the values are taken from serial is the sampling frequency for this system. This was calculated through the total number of samples that were read by MATLAB and the duration that it took to read those values.</p>
<pre><code>Fs = countRead / durationOfDataRead;
</code></pre>
<p>I generally found this sampling frequency of the existing code to be around 2000 Hz, varying in each run. In the script, MATLAB reads a huge set of character values from the serial port, and then splits it down to convert to double datatype. In lecture, we discussed another possible modification to this code which directly read a series of double values, potentially obtaining a lot more values in the same time to give a much larger sampling frequency. However, I was not able to get this method to work on my computer, thus restricting the frequency range to <code>0 to ~1000 Hz</code>. Since the frequency range of interest in this lab and the next one is up to 1000 Hz, this seemed suitable.</p>
<p>With this, I used the <code>fft</code> function of MATLAB to compute the FFT of the data, referring to the documentation of the function on their website. This was done over the following steps in the script.</p>
<pre><code>% Obtain FFT
L = length(dataDouble);
dataFFT = fft(dataDouble, L);
% Convert to one-sided spectrum
temp = abs(dataFFT / L);
dataFFT = temp(1:L/2+1);
dataFFT(2:end-1) = 2*dataFFT(2:end-1);
% Create the frequency axis from 0 to Fs 
freqAxis = Fs * (0:(L/2))/L;
</code></pre>
<p>Once the MATLAB script was ready and the Arduino code was uploaded, we had to test the system with the sound of frequency 500 Hz to obtain the sound output on a timescale and the frequency scale (spectrum) and observe a significant peak at 500 Hz. I also observed a very high peak at 0 Hz that represents the DC component of the sound wave and is supposed to be ignored. After running the script several times while changing the sound duration and the position of the breadboard with respect to the laptop speaker, I obtained the following plot for the simple microphone circuit with a distinguished peak at 500 Hz. I determined the appropriate duration of the sound with respect to the number of samples read to be 4-5s.</p>    
<figure>
    <center><i>
        <img src="images/lab3/mic_fft_500.png">
        <figcaption>Figure: Response of direct mic circuit at 500 Hz</figcaption>
    </i></center>
</figure>

<h2>
<a id="improved-microphone-with-amplifier" class="anchor" href="#improved-microphone-with-amplifer" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Improved Microphone with an Amplifier</h2>
<p>In the spectrum of the direct microphone output, we observe that while the peak is prominent, it is very low. Any microphone needs an amplifier circuit to produce an amplified sound output. For this, we built an amplifier circuit using the LM358, as described in the lectures, where R2, R3 = 10 KOhm, R4 = 3.3 KOhm, and R5 = 511 KOhm. The gain of this amplifier circuit is given by:</p>
<pre><code>Vout = - Vin * (R5 / R4) + Vcc / 2 
</code></pre>
<figure>
    <center><i>
        <img src="images/lab3/amp_schematic.png">
        <img src="images/lab3/amp_circuit.jpg">
        <figcaption>Figure: Schematic of amplifier with mic (from lecture notes) and circuit</figcaption>
    </i></center>
</figure>
<p>As can be seen in the circuit, I tried to keep all the components as close as possible, in order to reduce the amount of possible electrical noise. With this addition to the microphone, we ran the same MATLAB experiments like in the previous part and obtained much better results. As it can be seen, the peak at 500 Hz now goes up to 200 in amplitude (compared to 20 without the amplifier). This means that the observed gain is:</p>    
<pre><code>Vout / Vin = 235 / 22 = 10.68
</code></pre>
<figure>
    <center><i>
        <img src="images/lab3/amp_fft_500.jpg">
        <figcaption>Figure: Amplified FFT response at 500 Hz</figcaption>
    </i></center>
</figure>

    
<h2>
<a id="testing-lowpass-and-highpass" class="anchor" href="#testing-lowpass-and-highpass" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Testing Low pass and High pass Circuits</h2>
<p>Once the microphone and amplifier system was set up and tested, we moved to building and testing the filter circuits that were simulated in LTSpice earlier. For this, we first implemented both the circuits exactly from the schematic, with the amplifier output acting as the voltage source (or the input to the filter). The analog pin from the Arduino was now connected to the output (Vout) of the filter to measure the sound.</p>
<p>The aim of this part of the lab was to compare the theoretical and experimental responses of the two filters. In LTSpice, the plot obtained is the Bode plot of the circuit, showing the transfer function of the filter. The transfer function is defined as the ratio of the output of a system to the input of the system, given by <code>H(w) = Y(w) / X(w)</code>. In order to create a similar Bode plot of our circuit’s response, we had to calculate the spectrum of the sound output over a range of frequencies, both from before the filter (input of system) and after the filter (output of system). This was done by performing the same experiment multiple times, changing the connection of the Arduino’s analog pin in between.</p>
<p>The MATLAB script was modified to play a variable frequency sound, starting from 100 Hz till 1200 Hz. In order to keep a static sample size over different runs, I also introduced a way to slice all input data value arrays to a fixed size, without affecting the sampling frequency or the FFT. This meant that the input and output experiments always had the same length n-point FFT. I also varied the sound duration over different runs to find the most suitable one; which was as small as 2s. This was also suggested in the lecture to reduce the amount of noise, with the reasoning that concentrating all the frequencies in a smaller period of time will prevent any external noise from seeping through the signal. The number of samples read was adjusted accordingly, to only measure the sound that was played.</p>
<p>Once a seemingly appropriate response was obtained, I tried a range of different ways to compare the experimental results with the simulated ones. We were required to superpose the two transfer functions onto a single plot so that they can be easily compared. Since MATLAB retains all the variables of a script over a session, I performed different experiments with the input and output of the filter and stored the FFT into different variables. Now, before computing the transfer function from these variables, I also reduced the noise present in the curve with the help of <code>smoothdata</code> function in MATLAB, as suggested in the handout. Thus, I obtained the final curve to be plotted as follows.</p>
<pre><code>lowpass_H = smoothdata(dataFFT_LP, ‘sgolay’, 3000) ./ smoothdata(dataFFT, ‘sgolay’, 3000);
highpass_H = smoothdata(dataFFT_HP, ‘sgolay’, 3000) ./ smoothdata(dataFFT, ‘sgolay’, 3000);
</code></pre>
<p>After these curves were obtained, we were supposed to also produce the numerical data from LTSpice simulations and plot them together. Instead of using MATLAB to read that text data and plot with the transfer function curves above, I printed both all the data to text files and plotted it using Python (which I’m more comfortable with). This resulted in the following theoretical and experimental Bode plot.</p>
<figure>
    <center><i>
        <img src="images/lab3/lowpass_bode.png" width=48%>
        <img src="images/lab3/highpass_bode.png" width=48%>
        <figcaption>Figure: Theoretical and experimental transfer functions of low pass (left) and high pass (right) filter</figcaption>
    </i></center>
</figure>
<p>As was also the case with several other students in the class, my low pass and high pass filters did not behave as expected at all. The transfer curves from the experimental data differ drastically from the theoretical curves. Moreover, I found the sampling frequency of the high pass filter to always be lower than otherwise (about 1400 Hz), leading to a much limited range of the spectrum. All of these problems could be because of various noise and disturbances in the atmosphere, and also in the electrical connections across the breadboard. The transmission of samples through serial at variable rate could also be a problem leading to such results.</p>

<h2>
<a id="testing-bandpass-filter" class="anchor" href="#testing-bandpass-filter" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Testing the Bandpass Filter</h2>
<p>After having tested the other two filters, we were required to go through the same process with the bandpass filter. I first implemented the filter circuit, exactly following the schematic and using the amplifier output as the voltage source. I then performed the exact same experiment by obtaining sound output from the input and the output of the filter, and plotting the resultant transfer function along with that from LTSpice.</p>
<figure>
    <center><i>
        <img src="images/lab3/bandpass_bode.png" width=80%>
        <figcaption>Figure: Theoretical and experimental transfer functions of bandpass filter</figcaption>
    </i></center>
</figure>
<figure>
    <center><i>
        <img src="images/lab3/bandpass_circuit.jpg">
        <figcaption>Figure: Bandpass circuit on the breadboard</figcaption>
    </i></center>
</figure>
<p>The experimental response of the bandpass filter is somewhat similar to the theoretical transfer function, at least compared to that of the low pass and high pass filters. We see an attenuation of amplitudes in frequencies below the desired range, and an almost flat region in the pass band. The curve, however, seems to be a little shifted from the expectation. Moreover, since our set up limits the spectrum to a frequency range of up to 1000 Hz, we are not able to see if the amplitude of frequencies above the pass band are attenuated. Nonetheless, this curve might satisfy the requirement of this part of the lab, since we would be changing the complete set up for the following section.</p>

<h2>
<a id="fft-arduino" class="anchor" href="#fft-arduino" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>FFT on Arduino</h2>
<p>In the final part of this lab, we integrated all the learnings and implementations from previous sections into a system built on the Arduino Nano Every. This meant that the Arduino obtained the sound values from the microphone circuit (filtered or just amplified), and used those to natively compute the FFT and the spectrum of the sound, which was then outputted through serial to be plotted on the computer.</p>
<p>For the Fourier analysis on the Arduino, we used the ArduinoFFT library developed by Open Music Labs. This library makes it very straightforward to compute the FFT of a time signal on the Arduino efficiently. To account for the limited memory and compute capabilities of the Arduino, the library can only take 256 input values and calculates a 256-point FFT from it. In our code, we sample the sound signal at intervals of 0.41667 ms, which corresponds to a sampling frequency of 2400 Hz. Out of the 256 bins in the FFT, the first or second 128 half would map to the spectrum range of 0 to 1200 Hz, giving the following formula to compute the bin number of any frequency in the range.</p>
<pre><code>Bin # = Freq * 128 / 1200
</code></pre>
<p>With consideration of how the FFT library works, the Arduino sketch for this part of the lab was designed to be able to do the following.</p>
<ol>
<li>When started, read 257 values from the analog pin connected to the microphone through the ADC. This is done at a fixed interval of 0.41667 ms.</li> 
<li>Once 257 values are obtained, the first one is discarded (always 0) to leave 256 values for the FFT. No further ADC values are taken.</li> 
<li>The 256 values are shifted and scaled to obtain 16-bit sound wave data.</li> 
<li>These 256 values form the even indexed values of the 512-sized input array for the FFT. This represents the real component. The odd indices, representing the imaginary part, are filled with 0.</li> 
<li>Run the FFT computation as described in the library’s documentation.</li> 
<li>Output the 128-point FFT through serial.</li> 
<li>Pause execution.</li> 
</ol>
<p>The three major components of this code are the FFT library, ADC, and the TCA timer. Like in previous parts, the ADC was configured to be in the free-running mode so that it continuously reads the analog pins and outputs the data as it is generated. The setup of the ADC was exactly the same as earlier, so that the ADC values can be obtained at any time. Once all the 257 values were read, the ADC configuration was restored to default so that the normal <code>analogRead()</code> function can be used (in Lab 4). For that, the original register values of the ADC were stored in variables.</p>
<p>In order to obtain the ADC values at exactly 0.41667 ms intervals, we configured the TCA timer to trigger an interrupt at every 0.41667 ms. For this, we referred to the uploaded documentation and sample codes. Since this was a very small period, we set the timer to a high frequency and calculated the total number of ticks for this time period as follows. In the interrupt handler, a value was read from the ADC and stored in the data array, and a counter was incremented. After 257 reads, the handler also sets a flag to indicate that the data read is completed. Now, the timer is disabled and doesn’t generate any more interrupts.</p>
<pre><code>Time period = 0.41667ms (Corresponding to Fs = 2400 Hz)
fCLK_PER = 16 MHz
DIV2 --> fTCA = 8 MHz (higher resolution, lesser error)
# of Ticks = fTCA * Time period = 3333.33 --> 0xD05
</code></pre>
<p>Finally, the main loop executes when the data read from the ADC is complete. The 256 10-bit unsigned values are then shifted and scaled to obtain a signed 16-bit value sound signal, sampled at 2400 Hz. As described earlier, the input for the FFT is generated by manipulating this array into a 512-sized array called <code>fft_input</code> with real and imaginary components. Once the input is ready, the following four commands from the library are called insequence to generate a 256-point FFT of the input array, the output of which is stored in <code>fft_log_out</code>.</p>
<pre><code>// Window data for better freq response
fft_window();
// Reorder the data
fft_reorder();
// Calculate the FFT
fft_run();
// Get the ouptut of the FFT
fft_mag_log();
</code></pre>
<p>In the arduino sketch, the first 128 values of the output array are then printed to the serial monitor, from where the data can be copied and used to plot a stem plot representing the spectrum. In order to test this code, we were also provided with a MATLAB script that generates a fixed frequency sound for a period of time. This script was run after the code was loaded onto the Arduino to obtain the sound signal, calculate the FFT, and output the spectrum of the signal. Since the FFT occurs for a very short period of time at the very beginning of execution, we needed to make sure that the sound was being played when the Arduino started. I did this by running the script, and then instantly pressing the reset button on the Arduino connected to the computer with a serial monitor. This frequency spectrum was then plotted using Python.</p>
<p>We were required to perform the test for three different frequencies: 500 Hz, 700 Hz, and 900 Hz. I performed all three with two different outputs from the microphone circuit, one straight from the amplifier, and the other from the bandpass filter. Because of the erroneous performance of the low pass and high pass filters, I did not include them in this set up. The spectrums obtained for all three frequencies for both outputs are included below. In all of them, a peak is observed near the expected bin which can be calculated using the earlier formula as follows. In 500 Hz, we also observe another peak at about 1000 Hz, which is the first harmonic. We see that the bandpass filter does a good job of attenuating noise, while keeping the desired frequency peak prominent in all three cases. Therefore, it would be suitable to keep using the filter for the next lab.</p>
<pre><code>500 Hz:
Bin # = 500 * 128 / 1200 = 53
700 Hz:
Bin # = 700 * 128 / 1200 = 74
900 Hz:
Bin # = 900 * 128 / 1200 = 96
</code></pre>
<figure>
    <center><i>
        <img src="images/lab3/500Hz_noBP.png" width=48%>
        <img src="images/lab3/500Hz_BP.png" width=48%>
        <figcaption>Figure: FFT on the Arduino with 500 Hz sound without bandpass (left) and with (right)</figcaption>
    </i></center>
</figure>
<figure>
    <center><i>
        <img src="images/lab3/700Hz_noBP.png" width=48%>
        <img src="images/lab3/700Hz_BP.png" width=48%>
        <figcaption>Figure: FFT on the Arduino with 700 Hz sound without bandpass (left) and with (right)</figcaption>
    </i></center>
</figure>
<figure>
    <center><i>
        <img src="images/lab3/900Hz_noBP.png" width=48%>
        <img src="images/lab3/900Hz_BP.png" width=48%>
        <figcaption>Figure: FFT on the Arduino with 900 Hz sound without bandpass (left) and with (right)</figcaption>
    </i></center>
</figure>
<p>As a part of this code, I also created a way to visualize the FFT computed by the Arduino on the serial monitor itself. I added this as a function to the sketch, which prints the frequency spectrum obtained to serial with the help of ASCII art. This is convenient while testing and debugging because one doesn’t always have to copy over the serial data somewhere else to be able to visualize it using a plot. This function added at the end of the code produces an approximate stem plot on the serial as shown.</p> 
<figure>
    <center><i>
        <img src="images/lab3/700Hz_serial.png">
        <figcaption>Figure: FFT on the Arduino with 700 Hz sound visualized on the serial monitor</figcaption>
    </i></center>
</figure>   

<h2>
<a id="testing-and-problems" class="anchor" href="#testing-and-problems" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Testing and Problems</h2>
<p>This lab had been divided into three broad sections that were each supposed to be completed over successive weeks. As it has been described, the overall theme of the lab was itself testing different types of filter circuits and FFT mechanisms and comparing some of the experimental data with theoretical expectations obtained using LTSpice. The testing methodology followed for this entire process was completely based on observation, primarily through different frequency plots.</p>
<p>Over the course of the lab, I faced a few different problems. In the first part, I had initially incorrectly created some pins in the microphone circuit with the Arduino Nano. Luckily, I was able to identify the problem soon and it wasn’t something that might have spoiled a component. After that, I was unable to configure the ADC for free-running mode and it would always give me a static 1023. This, I found out with the help of the professor, was due to a typo. In the second week of the lab, I faced several issues with the two filter circuits as was described earlier. Like a lot of people in the class, I was unable to get reliable and appropriate results from either the low pass or high pass filter. While there were some code fixes that I did, that set up was left as it is to not be used again. The bandpass filter was comparatively better, but still not perfect. However, as was noted in the last part of the lab, it did do its job of assisting identification of frequency peaks. There weren’t any major issues faced in the last week.</p>    

        </section>

        <aside id="sidebar">
            <h3>Back to <a href="index.html">Home</a></h3>
            <h2><a href="#objective">Objective</a></h2>
            <h2><a href="#materials-used">Materials Used</a></h2>
            <h2><a href="#getting-familiar-with-ltspice">Getting Familiar with LTSpice</a></h2>
            <h2><a href="#building-and-testing-microphone">Building and Testing the Microphone Circuit</a></h2>
            <h2><a href="#improved-microphone-with-amplifier">Improved Microphone with an Amplifier</a></h2>
            <h2><a href="#testing-lowpass-and-highpass">Testing Low pass and High pass Circuits</a></h2>
            <h2><a href="#testing-bandpass-filter">Testing the Bandpass Filter</a></h2>
            <h2><a href="#fft-arduino">FFT on Arduino</a></h2>
            <h2><a href="#testing-and-problems">Testing and Problems</a></h2>
            <br>
            <p class="repo-owner"><a href="https://github.coecis.cornell.edu/kr397/ece3400-sp2021"></a>Maintained by <a href="https://github.coecis.cornell.edu/kr397">kr397</a>.</p>
  
            <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>
