{"name":"ECE 3400 Spring 2021 Wiki","tagline":"Krithik Ranjan kr397","body":"# **Lab 1** Light Following Robot Part 1\r\n\r\n## Objective \r\n\r\nThe goal of this lab was to familiarize ourselves with Arduino and some basic electrical components that we will be using to create a light following robot over the next few labs. In this course, we are using the Arduino Nano Every microcontroller board, which, in this lab, we connected to a dual photoresistor circuit set up on a breadboard. We tested the circuit by programming the Arduino and observing its print output through the serial terminal. The steps of this lab involved setting up the Arduino software environment on our local computer, testing some basic code, setting up the circuit, writing more complicated code that interfaces with the sensors and will be used to control the robot in future labs. \r\n\r\n## Installing the Arduino IDE\r\n\r\nAs described in the lab handout, I installed and set up the latest version of the Arduino IDE to be compatible with our Arduino Nano Every board. I also opened a few built-in examples to try out on the Arduino (that could work without any additional hardware). \r\n\r\nHaving worked with the Arduino before and being familiar with the IDE, I ventured out to learn some advanced methods of using the Arduino. The Arduino organization has recently launched a command line tool called `arduino-cli` that can be used to perform all the functions of the IDE, straight from the terminal. This was an exciting, new application that can make it faster and easier (in some cases) to work with the Arduino. A detailed introduction to this can be found at Arduino’s blog at [Arduino CLI: An Introduction] (https://blog.arduino.cc/2020/03/13/arduino-cli-an-introduction/). \r\n\r\nUsing the CLI involves a simple download from their website and adding it to the user’s path, after which, it can be directly used on the terminal with `arduino-cli` (shown on Windows Terminal - Powershell). The tool can then be set up and used with the Arduino Nano Every as described in the following steps. \r\n\r\n1. First, to install the board onto the system, connect it to the computer and run the following commands. \r\n```\r\n> arduino-cli board list\r\n```\r\nwill show the connected boards with details about their ports and cores. \r\n``` \r\n> arduino-cli core list \r\n```\r\nwill show all of the cores (boards) that have been installed. \r\n```\r\n> arduino-cli core install arduino:megaavr\r\n``` \r\nwill install the core (as shown in the `board list` command). \r\n\r\n2. Once the board has been installed, a new sketch can be created as follows. This creates the `blink.ino` file in the folder `blink` as per Arduino’s convention. \r\n```\r\n> arduino-cli sketch new blink\r\n```\r\n3. The sketch can be compiled with the following command with a `-b` flag to specify the board that it needs to be compiled for, using the FQBN displayed in the `board list` command. The verbose `-v` flag can be used for a detailed output. \r\n```\r\n> arduino-cli compile -b arduino:megaavr:nona4809\r\n```\r\n\r\n4. This compiled sketch can then be uploaded to the board by specifying the FQBN and the port as shown. The `-v` flag will give the complete output. \r\n```\r\n> arduino-cli upload -b arduino:megaavr:nona4809 -p COM5\r\n```\r\n\r\n5. To prevent having to type things like the FQBN and serial port every time we compile and upload a sketch, we can attach a board to the particular sketch (like it is done in the IDE). This can be done by passing in the serial port. \r\n``` \r\n> arduino-cli board attach COM5\r\n```\r\n6. For further increase in efficiency, once a board is attached, we can compile and upload a sketch in a single command as well. \r\n```\r\n> arduino-cli compile --upload\r\n```\r\n\r\nThis is a brief crash course for the Arduino CLI tool compiled with the help of their existing tutorials and blog posts, which I have included here for future reference in the labs.\r\n\r\n### Creating pages manually\r\nIf you prefer to not use the automatic generator, push a branch named `gh-pages` to your repository to create a page manually. In addition to supporting regular HTML content, GitHub Pages support Jekyll, a simple, blog aware static site generator. Jekyll makes it easy to create site-wide headers and footers without having to copy them across every page. It also offers intelligent blog support and other advanced templating features.\r\n\r\n### Authors and Contributors\r\nYou can @mention a GitHub username to generate a link to their profile. The resulting `<a>` element will link to the contributor’s GitHub Profile. For example: In 2007, Chris Wanstrath (@defunkt), PJ Hyett (@pjhyett), and Tom Preston-Werner (@mojombo) founded GitHub.\r\n\r\n### Support or Contact\r\nHaving trouble with Pages? Check out our [documentation](https://help.github.com/pages) or [contact support](https://github.com/contact) and we’ll help you sort it out.\r\n","note":"Don't delete this file! It's used internally to help with page regeneration."}